name: Release Captain

on:
  push:
    branches: [main, master]
  schedule:
    - cron: '0 8 * * *'  # Daily at 8am UTC
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        type: choice
        options:
          - auto
          - patch
          - minor
          - major

permissions:
  contents: write
  pull-requests: write

jobs:
  check:
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      version_bump: ${{ steps.analyze.outputs.bump }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for unreleased changes
        id: check
        run: |
          # Get last release tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            echo "No previous release found"
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "commits_since=all" >> $GITHUB_OUTPUT
          else
            COMMITS=$(git rev-list --count $LAST_TAG..HEAD)
            echo "Commits since $LAST_TAG: $COMMITS"
            
            if [ "$COMMITS" -gt 0 ]; then
              echo "should_release=true" >> $GITHUB_OUTPUT
              git log --oneline $LAST_TAG..HEAD > commits-since-release.txt
            else
              echo "should_release=false" >> $GITHUB_OUTPUT
            fi
          fi
          
          echo "last_tag=$LAST_TAG" >> $GITHUB_OUTPUT

      - name: Analyze commits for version bump
        id: analyze
        if: steps.check.outputs.should_release == 'true'
        run: |
          # Analyze commit messages for conventional commits
          BREAKING=$(grep -ciE "^BREAKING|!" commits-since-release.txt 2>/dev/null || echo 0)
          FEAT=$(grep -ciE "^feat" commits-since-release.txt 2>/dev/null || echo 0)
          FIX=$(grep -ciE "^fix" commits-since-release.txt 2>/dev/null || echo 0)
          
          if [ "${{ github.event.inputs.release_type }}" != "" ] && [ "${{ github.event.inputs.release_type }}" != "auto" ]; then
            echo "bump=${{ github.event.inputs.release_type }}" >> $GITHUB_OUTPUT
          elif [ "$BREAKING" -gt 0 ]; then
            echo "bump=major" >> $GITHUB_OUTPUT
          elif [ "$FEAT" -gt 0 ]; then
            echo "bump=minor" >> $GITHUB_OUTPUT
          else
            echo "bump=patch" >> $GITHUB_OUTPUT
          fi

  prepare-release:
    needs: check
    if: needs.check.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get commits for changelog
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -n "$LAST_TAG" ]; then
            git log --pretty=format:"- %s (%h)" $LAST_TAG..HEAD > commits.txt
          else
            git log --pretty=format:"- %s (%h)" > commits.txt
          fi

      - name: Calculate new version
        id: version
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          VERSION=${LAST_TAG#v}
          
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
          
          case "${{ needs.check.outputs.version_bump }}" in
            major)
              NEW_VERSION="$((MAJOR + 1)).0.0"
              ;;
            minor)
              NEW_VERSION="$MAJOR.$((MINOR + 1)).0"
              ;;
            patch)
              NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
              ;;
          esac
          
          echo "new_version=v$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version will be: v$NEW_VERSION"

      - name: Generate changelog entry
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          prompt_file: .github/agents/prompts/release-captain.md
          context_files: commits.txt CHANGELOG.md
          additional_context: |
            New version: ${{ steps.version.outputs.new_version }}
            Bump type: ${{ needs.check.outputs.version_bump }}
            Date: $(date +%Y-%m-%d)
          output_mode: file
          output_file: changelog-entry.md

      - name: Update CHANGELOG.md
        run: |
          if [ -f "CHANGELOG.md" ]; then
            # Insert new entry after header
            sed -i '/^# Changelog/r changelog-entry.md' CHANGELOG.md
          else
            echo "# Changelog" > CHANGELOG.md
            cat changelog-entry.md >> CHANGELOG.md
          fi

      - name: Create Release PR
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "ðŸš€ Release ${{ steps.version.outputs.new_version }}"
          title: "ðŸš€ Release ${{ steps.version.outputs.new_version }}"
          body: |
            ## Release ${{ steps.version.outputs.new_version }}
            
            This PR was automatically generated by the Release Captain.
            
            ### Changes
            $(cat commits.txt)
            
            ### Checklist
            - [ ] Changelog looks correct
            - [ ] Version bump is appropriate (${{ needs.check.outputs.version_bump }})
            - [ ] All CI checks pass
            
            Merge this PR to create the release.
          branch: release/${{ steps.version.outputs.new_version }}
          labels: release,agent-generated
